---
title: 走进shell基础命令
date: 2023-7-29 20:00:00
update: 2023-7-30 22:00:00
tags:
  - shell
  - linux
categories:
  - study
---
# 走进shell基础命令
[toc]

## 1. 什么是shell

   * Bash shell是一种Unix/Linux系统中的命令行shell解释器，是Bourne shell（sh）的一种替代品。它是一个基于文本的界面，用于与操作系统交互，并执行各种任务和程序。

   * Bash shell可以让用户运行和管理系统中的各种命令和程序，包括文件和目录管理、系统配置、软件安装和配置等等。用户可以通过输入命令来与Bash shell交互，它会解释和执行这些命令，并显示结果。Bash shell也支持shell脚本，可以用来自动化和批量处理任务。

     + 疑问???: Shell, Terminal傻傻分不清???

     1. Shell
     
     {% mermaid %}
     graph LR;
     	A[Shell外壳程序] --> B(接受命令)
     	A --> C(图形化Shell,命令行Shell)
     {% endmermaid %}
     
     2. Terminal
     
     {% mermaid %}
     graph LR;
     	B(命令的输入输出环境) --> 
     	A[Terminal终端] --> C(终端设备)
     	A --> D(终端模拟器)
     {% endmermaid %}
     
      * 由于早期的计算机比较昂贵(现在也是), 无法为每一个人配一台计算机, 但是终端设备往往比较便宜, 因此可以给每一个人配置一套终端设备, 连接到同一台计算机上. 就像下面酱紫:
     
        {% mermaid %}
        graph LR;
        	用户 --> 终端设备 --> 通信通道 --> 计算机--> 命令行Shell
        {% endmermaid %}
     
        如图: 用户先是通过终端设备输入命令, 命令通过通信通道传递给计算机, 计算机开始启动相关命令行Shell
     
      * 但是现在计算机没有那么贵了, 使用更多的是一种终端模拟器(简称终端, 实际上两者完全不一样), 用以模拟当年终端设备的一些个软件, 就像酱紫:
     
        {% mermaid %}
        graph LR;
        A[用户] --> B[计算机]
        B --> C[终端模拟器]
        B --> D[命令行Shell]
        C --> |操作系统提供的信道| D
        {% endmermaid %}
        现在明白了这些东西的区别, 那么我们常见的那些命令行工具都属于什么呢?
     
        | 操作系统 | 终端模拟器                            | Shell                   |
        | -------- | ------------------------------------- | ----------------------- |
        | Windows  | conhost.exe(自带终端), WezTerm        | cmd.exe, PowerShell     |
        | Linux    | 众多, 基本每一个Linux发行版都会带一个 | bash shell, Cshell, zsh |
        
        > Shell的输入和输出并不是大家想象的那么简单, 你看到的哪些花花绿绿的颜色其实是由一套规则决定的: Virtual Terminal Sequence; 有机会 && 我有时间的话再向大家介绍, 大家也可自行google!!!
     
   * shell的常见种类
   
     | 名称                                   | 简介                                                         |
     | -------------------------------------- | ------------------------------------------------------------ |
     | Bourne Shell (sh)                      | 由 Steve Bourne 开发的原始 Unix shell，它是大多数 Unix 系统中默认的 shell |
     | Bash Shell (bash) - Bourne-Again SHell | 是对 Bourne Shell 的增强版，它是 Linux 系统中默认的 shell    |
     | Korn Shell (ksh)                       | 由 David Korn 开发的 Unix shell，其设计目标是将 Bash Shell 和 C Shell 的优点结合起来 |
     | C Shell (csh)                          | 由 Bill Joy 开发的 Unix shell，其语法类似于 C 语言。         |
     | Tcsh Shell (tcsh)                      | 是 C Shell 的增强版，提供了更多的功能和改进的命令行编辑功能。 |
   
     > 除了这些常见的 shell 之外，还有一些其他的 shell，例如 Zsh、Fish 等。每种 shell 都有其特定的语法和功能，可以根据需要选择适合自己的 shell。

## 2. 基本shell命令

### 2.0. 常用快捷键

| 快捷键    | 功能             |
| --------- | ---------------- |
| ctrl + alt + t | 打开终端 |
| ctrl + c | 终止运行当前进程 |
| Tab       | 命令自动补全     |
| Tab + Tab |    提示命令     |
| ctrl + insert | 复制 |
| shift + insert | 粘贴 |
| 上 | 查看历史命令 |
| ctrl + l | 清屏(相当于clear命令) |
| ctrl + a | 光标移动到行首 |
| ctrl + e | 光标移动到行尾 |
| ctrl + r | 搜索历史命令 |
| ctrl + z | 挂起当前进程 |
| ctrl + d | 退出当前shell |

### 2.1. 与bash手册交互

* man命令
大多数Linux发行版自带在线手册, 可以使用man命令查找使用手册

手册使用:

| 段落 | 说明 |
| ---- | ---- |
| NAME | 命令的名称和一行简单的描述 |
| SYNOPSIS | 命令的语法 |
| DESCRIPTION | 命令的详细描述 |
| OPTIONS | 命令的选项 |
| EXIT STATUS | 命令的退出状态 |
| RETURN VALUE | 命令的返回值 |
| ERRORS | 命令的错误信息 |
| ENVIRONMENT | 命令的环境变量 |
| FILES | 命令的相关文件 |
| VERSIONS | 命令的版本信息 |
| CONFORMING TO | 命令的标准 |
| NOTES | 命令的注意事项 |
| BUGS | 命令的已知BUG |
| EXAMPLE | 命令的示例 |
| AUTHORS | 命令的作者 |
| COPYRIGHT | 命令的版权信息 |
| SEE ALSO | 命令的相关信息 |

### 2.2. 浏览文件系统
* Linux的文件系统
  * 根目录（/）: 根目录是整个目录树的最顶层，它是所有其他目录和文件的起点。
  * /bin：这个目录包含了可执行的系统命令，如ls、cp、mv等。
  * /boot：该目录包含了启动Linux系统所需的文件，如内核和引导加载程序。
  * /dev：这个目录包含了设备文件，用于与硬件设备进行交互，如磁盘驱动器、打印机、终端等。
  * /etc：这个目录包含了系统配置文件，如网络配置、用户账户信息等。
  * /home：每个用户都有一个独立的目录，用于存储个人文件和设置。用户的个人目录通常位于/home/username下。
  * /lib和/lib64：这些目录包含了共享库文件，它们是程序在运行时所需的依赖文件。
  * /media和/mnt：这些目录通常用于挂载外部存储设备，如光盘、USB驱动器等。
  * /opt：该目录用于安装可选的第三方软件包。
  * /proc：这个虚拟文件系统提供了有关系统和进程的运行时信息。
  * /root：这是超级用户（root）的个人目录。
  * /sbin：类似于/bin目录，包含了系统管理员使用的系统命令。
  * /tmp：这个目录用于存储临时文件。
  * /usr：这个目录包含了系统范围的应用程序和文件，如用户程序、库文件和文档。
  * /var：这个目录包含了可变的数据文件，如日志文件、邮件和打印队列。
  > 其中虚拟目录为bin, dev, home, lib64, proc, root, sys, tmp, usr, var, 他们并不是真实存在的目录, 而是在内存中的目录, 用于存储系统信息, 例如: /proc/cpuinfo, /proc/meminfo, /proc/version等等
  > FHS偶尔会更新, 想要保持与FHS标准同步, 请访问其官方网页

* 相对路径与绝对路径
  * 相对路径: 相对于当前目录的路径
  * 绝对路径: 从根目录开始的路径
  
* cd与pwd命令
  * cd命令: 用于切换当前工作目录
  ```shell
  # 语法: cd [目录]
  # 1. 切换到当前用户的主目录
  cd ~
  # 2. 切换到上一次所在的目录
  cd -
  # 3. 切换到根目录
  cd /
  # 4. 切换到上一级目录
  cd ..
  # 5. 切换到目录root
  cd /root
  # ...
  ```
  * pwd命令: 用于显示当前工作目录的绝对路径
  ```shell
  # 语法: pwd
  pwd
  ```
  输出结果: 

  ![image-20230625135329365](img/image-20230625135329365.png)

### 2.3. 文件与目录管理
  * ls 命令: 用于列出指定目录中的文件和子目录

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -a   | 显示所有文件和子目录，包括隐藏文件                           |
  | -l   | 显示文件和子目录的详细信息，包括文件的权限、所有者、大小、创建时间等 |
  | -t   | 按照时间排序，最新修改的文件和子目录在前面                   |
  | -r   | 逆序显示，与-t选项一起使用，最新修改的文件和子目录在后面     |
  | -F   | 在每个文件和子目录的名称后面添加一个字符，用于表示该文件或子目录的类型，如/表示目录，*表示可执行文件，@表示符号链接，=表示套接字，|表示FIFO |
  | -h   | 以人类可读的方式显示文件和子目录的大小，如1K、2M、3G等      |
  | ... | ...                                                          |

  ```shell
  # 语法: ls [选项] [目录]
  # 1. 列出当前目录中的文件和子目录
  ls
  # 2. 列出指定目录中的文件和子目录
  ls /etc
  # 3. 列出指定目录中的文件和子目录, 并显示详细信息
  ls -l /etc
  # 4. 列出指定目录中的文件和子目录, 并显示隐藏文件
  ls -a /etc
  # 5. 列出指定目录中的文件和子目录, 并显示详细信息和隐藏文件
  ls -al /etc
  # 6. 列出指定目录中的文件和子目录, 并显示详细信息和隐藏文件, 并按照时间排序
  ls -alt /etc
  ```

  另外, 由于大部分的Linux发行版会在~/.bashrc默认为ls -a, ls -l等设置别名, 因此可以直接使用ll, la等命令, 如图: 

  ![image-20230625135927724](img/image-20230625135927724.png)

  过滤输出列表:
  ls命令支持在命令行中定义过滤器

  | 过滤器 | 说明                                                         |
  | ------ | ------------------------------------------------------------ |
  | *      | 匹配任意多个字符，如*.txt匹配所有以.txt结尾的文件            |
  | ?      | 匹配任意一个字符，如?.txt匹配a.txt、b.txt等                   |
  | []     | 匹配方括号中任意一个字符，如[abc].txt匹配a.txt、b.txt、c.txt等 |
  | [!]    | 匹配方括号中任意一个不包含的字符，如[!abc].txt匹配除了a.txt、b.txt、c.txt之外的文件 |
  | {}     | 匹配花括号中任意一个字符串，如{abc,def}.txt匹配abc.txt、def.txt等 |
  | {n}    | 匹配花括号中前面字符串出现的次数，如{1}.txt匹配所有单个字符组成的文件名，{2}.txt匹配所有由两个字符组成的文件名 |
  | {n,m}  | 匹配花括号中前面字符串出现的次数，如{1,3}.txt匹配所有由1~3个字符组成的文件名 |
  | ...    | ...                                                          |

  ```shell
  # 语法: ls [过滤器]
  ls *.txt
  ls a?.txt
  ls [abc].txt
  ls [!abc].txt
  ls {abc,def}.txt
  # ...
  ```

### 2.4. 处理文件

#### 2.4.1. 创建文件

* touch命令: 用于创建空文件或更新文件的时间戳

  ```shell
  # 语法: touch [选项] 文件
  # 1. 创建空文件
  touch a.txt
  # 2. 创建多个空文件
  touch a.txt b.txt c.txt
  # 3. 创建空文件, 并指定时间戳
  touch -t 202106251400 a.txt
  ```

#### 2.4.2. 复制文件

* cp命令: 用于复制文件或目录

  ```shell
  # 语法: cp [选项] 源文件 目标文件
  # 1. 复制文件
  cp a.txt b.txt
  # 2. 复制目录
  cp -r /etc /etc.bak
  # 3. 复制目录, 并指定时间戳
  cp -r -p /etc /etc.bak
  ```

#### 2.4.3. 文件重命名与移动

* mv命令: 用于移动文件或目录，也可以用于重命名文件或目录

  ```shell
  # 语法: mv [选项] 源文件 目标文件
  # 1. 重命名文件
  mv a.txt b.txt
  # 2. 重命名目录
  mv /etc /etc.bak
  # 3. 移动文件
  mv a.txt /etc
  # 4. 移动目录
  mv /etc /root
  ```

#### 2.4.4. 删除文件

* rm命令: 用于删除文件或目录

  ```shell
  # 语法: rm [选项] 文件
  # 1. 删除文件
  rm a.txt
  # 2. 删除目录
  rm -r /etc
  # sudo rm -rf /*  # 删库跑路, 切勿尝试!!!>_<
  # 3. 删除目录, 并指定时间戳
  rm -r -p /etc
  ```

#### 2.4.5. 查看文件内容

* cat命令: 用于查看文件内容

  ```shell
  # 语法: cat [选项] 文件
  # 1. 查看文件内容
  cat a.txt
  # 2. 查看多个文件内容
  cat a.txt b.txt c.txt
  # 3. 查看文件内容, 并显示行号
  cat -n a.txt
  # 4. 查看文件内容, 并显示行号, 并显示空行
  cat -b a.txt
  # 5. 查看文件内容, 并显示行号, 并显示空行, 并显示制表符
  cat -T a.txt
  ```

* more命令: 用于分页显示文件内容

  ```shell
  # 语法: more 文件
  # 1. 分页显示文件内容
  more a.txt
  # 2. 分页显示文件内容, 并显示行号
  more -n a.txt
  ```

* less命令: 用于分页显示文件内容，与more命令类似，但是less命令支持向前翻页

  ```shell
  # 语法: less 文件
  # 1. 分页显示文件内容
  less a.txt
  # 2. 分页显示文件内容, 并显示行号
  less -n a.txt
  ```

> 三者的区别:
> cat：这是concatenate的简写，主要用于读取、合并和创建文件。当你用cat命令查看文件内容时，它会立即输出整个文件的内容。对于大文件，这可能会导致屏幕快速滚动，使得很难查看全部内容。
> more：这个命令也用于查看文件内容，但它会分页显示文件内容。在你看完一页后，你需要按空格键或回车键才能看下一页。然而，more命令的一个限制是你不能向后翻页，只能向前。
> less：与more命令类似，less命令也是分页显示文件内容。但是，它具有一些更强大的功能，比如向前和向后翻页，搜索，跳转等。这使得less命令在查看大文件时特别有用。
> 总的来说，如果你需要查看的文件比较小，可以使用cat命令。如果文件比较大，而且你只需要向前翻页，那么more命令就很有用。但是，如果你需要在大文件中进行更复杂的操作，如向前和向后翻页，搜索，跳转等，那么less命令将是最好的选择。

* head命令: 用于显示文件的前几行，默认显示前10行

  ```shell
  # 语法: head [选项] 文件
  # 1. 显示文件的前10行
  head a.txt
  # 2. 显示文件的前5行
  head -n 5 a.txt
  # 3. 显示文件的前5个字符
  head -c 5 a.txt
  ```

* tail命令: 用于显示文件的后几行，默认显示后10行

  ```shell
  # 语法: tail [选项] 文件
  # 1. 显示文件的后10行
  tail a.txt
  # 2. 显示文件的后5行
  tail -n 5 a.txt
  # 3. 显示文件的后5个字符
  tail -c 5 a.txt
  # 4. 显示文件的后10行, 并持续显示
  tail -f a.txt
  ```

### 2.5. 管理目录

#### 2.5.1. 创建目录

* mkdir命令: 用于创建目录

  ```shell
  # 语法: mkdir [选项] 目录
  # 1. 创建单个目录
  mkdir dir1
  # 2. 创建多个目录
  mkdir dir1 dir2 dir3
  # 3. 创建多级目录
  mkdir -p dir1/dir2/dir3
  ```

#### 2.5.2. 删除目录

* rmdir命令: 用于删除空目录(...个人认为最没用的命令)

  ```shell
  # 语法: rmdir [选项] 目录
  # 1. 删除单个空目录
  rmdir dir1
  # 2. 删除多个空目录
  rmdir dir1 dir2 dir3
  # 3. 删除多级空目录
  rmdir -p dir1/dir2/dir3
  ```

* rm命令: 用于删除文件或目录
综上

## 3. 更多的shell命令

### 3.1. 检测程序

#### 3.1.1. 检测进程

* ps命令: 用于查看当前系统中的进程

  ```shell
  # 语法: ps [选项]
  # 1. 查看当前系统中的进程
  ps
  # 2. 查看当前系统中的进程, 并显示详细信息
  ps -ef
  # 3. 查看当前系统中的进程, 并显示详细信息, 并显示进程树
  ps -ef --forest
  # 4. 查看当前系统中的进程, 并显示详细信息, 并显示进程树, 并显示进程树的线程
  ps -ef --forest -L
  # 5. 查看当前系统中的进程, 并显示详细信息, 并显示进程树, 并显示进程树的线程, 并显示进程树的线程的线程
  ps -ef --forest -L -T
  # 6. 查看当前系统中的进程, 并显示详细信息, 并显示进程树, 并显示进程树的线程, 并显示进程树的线程的线程, 并显示进程树的线程的线程的线程
  ps -ef --forest -L -T -m
  # 7. 查看当前系统中的进程, 并显示详细信息, 并显示进程树, 并显示进程树的线程, 并显示进程树的线程的线程, 并显示进程树的线程的线程的线程
  ps -ef --forest -L -T -m -H
  # 8. 查看当前系统中的进程, 并显示详细信息, 并显示进程树, 并显示进程树的线程, 并显示进程树的线程的线程, 并显示进程树的线程的线程的线程, 并显示进程树的线程的线程的线程的线程
  ps -ef --forest -L -T -m
  # 艾玛, 忒多了...
  ```

#### 3.1.2. 实时检测进程

   * top命令: 用于实时显示系统中各个进程的资源占用情况

     ```shell
     # 语法: top
     # 1. 实时显示系统中各个进程的资源占用情况
     top
     ```
     运行结果:

     ![image-20230625141946175](img/image-20230625141946175.png)

      PID: 进程ID
      USER: 进程所有者
      PR: 进程优先级
      NI: 进程的优先级数值
      VIRT: 进程占用的虚拟内存大小
      ...

    #### 3.1.3. 结束进程
    
    * kill命令: 用于终止进程
      
      ```shell
      # 语法: kill [选项] 进程ID
      # 1. 终止进程
      kill 1234
      # 2. 终止进程, 并指定信号
      kill -9 1234
      ```
      
      | 信号 | 说明                                                         |
      | ---- | ------------------------------------------------------------ |
      | 1    | SIGHUP，该信号用于通知进程其父进程已经终止，进程需要重新读取配置文件 |
      | 2    | SIGINT，该信号用于通知进程中断当前的操作，通常由Ctrl+C发送    |
      | 3    | SIGQUIT，该信号用于通知进程退出，通常由Ctrl+\发送            |
      | 9    | SIGKILL，该信号用于强制终止进程，进程无法忽略该信号           |
      | 15   | SIGTERM，该信号用于通知进程正常终止，进程可以忽略该信号       |
      | ...  | ...                                                          |
    
      * pkill命令: 用于根据进程名终止进程
    
        ```shell
        # 语法: pkill [选项] 进程名
        # 1. 根据进程名终止进程
        pkill firefox
        # 2. 根据进程名终止进程, 并指定信号
        pkill -9 firefox
        ```
    
        > 由于kill命令需要指定进程ID, 但是进程ID是动态的, 因此pkill命令就诞生了, 他可以根据进程名终止进程

### 3.2. 检测磁盘空间

#### 3.2.1. 挂载存储设备

* mount命令: 用于挂载存储设备

* umount命令: 用于卸载存储设备

#### 3.2.2. 使用df命令检测磁盘空间

* df命令: 

```shell
# 语法: df [选项]
# 1. 检测磁盘空间
df
# 2. 检测磁盘空间, 并显示详细信息
df -h
# 3. 检测磁盘空间, 并显示详细信息, 并显示所有文件系统
df -ha
# ...
```

| 选项 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 显示所有文件系统，包括系统保留的文件系统                     |
| -h   | 以人类可读的方式显示磁盘空间，如1K、2M、3G等                |
| -H   | 以人类可读的方式显示磁盘空间，如1K、2M、3G等，但是1K=1000字节 |
| -i   | 显示磁盘空间的inode信息，包括总inode数、已使用的inode数和剩余的inode数 |
| -k   | 以KB为单位显示磁盘空间，1K=1024字节                          |
| -l   | 仅显示本地文件系统                                           |
| -m   | 以MB为单位显示磁盘空间，1M=1024KB                             |
| -P   | 以POSIX标准的格式显示磁盘空间，1K=1024字节                   |
| -t   | 仅显示指定类型的文件系统                                     |
| ... | ...                                                          |

#### 3.2.3. 使用du命令检测磁盘空间

...

### 3.3. 处理数据文件

#### 3.3.1. 数据排序

* sort命令: 用于对数据文件进行排序

  ```shell
  # 语法: sort [选项] 文件
  # 1. 对数据文件进行排序
  sort a.txt
  # 2. 对数据文件进行排序, 并去重
  sort -u a.txt
  # 3. 对数据文件进行排序, 并指定分隔符
  sort -t : a.txt
  # 4. 对数据文件进行排序, 并指定分隔符, 并指定列
  sort -t : -k 2 a.txt
  # 5. 对数据文件进行排序, 并指定分隔符, 并指定列, 并指定列的类型
  sort -t : -k 2 -n a.txt
  # 6. 对数据文件进行排序, 并指定分隔符, 并指定列, 并指定列的类型, 并指定列的排序方式
  sort -t : -k 2 -n -r a.txt
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -b   | 忽略每行前面的空格字符                                       |
  | -d   | 按照字典顺序排序                                             |
  | -f   | 忽略每行中的大小写                                           |
  | -g   | 按照一般数值排序                                             |
  | -i   | 忽略每行中的非打印字符                                       |
  | -M   | 按照月份排序                                                 |
  | -n   | 按照数值排序                                                 |
  | -r   | 逆序排序                                                     |
  | -t   | 指定分隔符                                                   |
  | -k   | 指定列                                                       |
  | ... | ...                                                          |

#### 3.3.2. 数据搜索

* grep命令: 
当需要在文本文件中搜索指定模式的行时，grep 是一个非常有用的命令行工具。它的名字来源于 "Global Regular Expression Print"（全局正则表达式打印），因为它最初设计用于在文件中查找匹配某个正则表达式模式的行，并打印出来。

grep 命令的基本语法如下：

```shell
grep [选项] 模式 [文件...]
```
其中，选项是可选的，用于指定不同的搜索行为。模式是你要搜索的文本模式，可以是简单的字符串或者更复杂的正则表达式。文件是要搜索的文件列表，可以是一个或多个文件。

下面是一些常用的 grep 选项：

-i：忽略大小写进行匹配。
-v：反转匹配，只输出不匹配的行。
-r：递归搜索子目录。
-l：只输出包含匹配模式的文件名。
-n：显示匹配行的行号。
除了 grep，还有两个相关的命令 egrep 和 fgrep，它们都是 grep 的变体。

egrep 命令也称为 grep -E，它支持更扩展的正则表达式语法。具体来说，它使用扩展的正则表达式（Extended Regular Expression）进行模式匹配。如果你想使用特殊字符（如 +、|、() 等）进行匹配，那么 egrep 是一个更好的选择。

fgrep 命令也称为 grep -F，它执行固定字符串（Fixed Strings）的匹配，而不是正则表达式匹配。这意味着 fgrep 不会将模式中的特殊字符解释为正则表达式元字符，而是将它们视为普通的字符串进行搜索。

这是 egrep 和 fgrep 命令的基本语法：

```shell
egrep [选项] 模式 [文件...]
fgrep [选项] 字符串 [文件...]
```

#### 3.3.3. 数据压缩与归档

* gzip命令: 用于压缩文件

  ```shell
  # 语法: gzip [选项] 文件
  # 1. 压缩文件
  gzip a.txt
  # 2. 压缩文件, 并指定压缩级别
  gzip -9 a.txt
  # 3. 压缩文件, 并指定压缩级别, 并指定压缩文件名
  gzip -9 -c a.txt > a.txt.gz
  # 4. 压缩文件, 并指定压缩级别, 并指定压缩文件名, 并删除原文件
  gzip -9 -c a.txt > a.txt.gz && rm -f a.txt
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -1   | 压缩级别1，压缩比最低，但是压缩速度最快                       |
  | -9   | 压缩级别9，压缩比最高，但是压缩速度最慢                       |
  | -c   | 将压缩后的数据输出到标准输出，而不是写入文件                 |
  | -d   | 解压缩文件                                                   |
  | -f   | 强制压缩，即使压缩文件已经存在                               |
  | -k   | 保留原始文件                                                 |
  | -l   | 显示压缩文件的信息                                           |
  | -r   | 递归压缩目录                                                 |
  | -t   | 测试压缩文件的完整性                                         |
  | -v   | 显示压缩或解压缩的详细信息                                   |
  | ... | ...                                                          |

* gunzip命令: 用于解压缩文件

  ```shell
  # 语法: gunzip [选项] 文件
  # 1. 解压缩文件
  gunzip a.txt.gz
  # 2. 解压缩文件, 并指定解压缩文件名
  gunzip -c a.txt.gz > a.txt
  # 3. 解压缩文件, 并指定解压缩文件名, 并删除原文件
  gunzip -c a.txt.gz > a.txt && rm -f a.txt.gz
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -c   | 将解压缩后的数据输出到标准输出，而不是写入文件               |
  | -f   | 强制解压缩，即使解压缩文件已经存在                           |
  | -k   | 保留原始文件                                                 |
  | -l   | 显示解压缩文件的信息                                         |
  | -r   | 递归解压缩目录                                               |
  | -t   | 测试解压缩文件的完整性                                       |
  | -v   | 显示解压缩的详细信息                                         |
  | ... | ...                                                          |

  * tar命令: 用于数据压缩, 解压缩以及归档

  ```shell
  # 语法: tar [选项] 文件
  # 1. 压缩文件
  tar -zcvf a.tar.gz a.txt
  # 2. 压缩文件, 并指定压缩级别
  tar -zcvf a.tar.gz a.txt
  # 3. 压缩文件, 并指定压缩级别, 并指定压缩文件名
  tar -zcvf a.tar.gz a.txt
  # 4. 压缩文件, 并指定压缩级别, 并指定压缩文件名, 并删除原文件
  tar -zcvf a.tar.gz a.txt
  # 5. 解压缩文件, 并指定解压缩文件名, 并删除原文件
  tar -zcvf a.tar.gz a.txt
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -c   | 创建归档文件                                                 |
  | -x   | 解压缩归档文件                                               |
  | -z   | 使用gzip压缩或解压缩归档文件                                 |
  | -j   | 使用bzip2压缩或解压缩归档文件                                |
  | -v   | 显示归档或解归档的详细信息                                   |
  | -f   | 指定归档文件                                                 |
  | -t   | 显示归档文件的内容                                           |
  | -p   | 保留文件的权限和属性                                         |
  | -P   | 使用绝对路径                                                 |
  | -r   | 向归档文件中追加文件                                         |
  | -u   | 仅向归档文件中追加比归档文件中更新的文件                     |
  | -k   | 保留原始文件                                                 |
  | -l   | 解压缩软链接                                                 |
  | -h   | 解压缩硬链接                                                 |
  | ... | ...                                                          |

### 3.4. 管理用户

#### 3.4.1. 添加用户

* adduser命令: 用于添加用户

  ```shell
  # 语法: adduser [选项] 用户名
  # 1. 添加用户
  adduser user1
  # 2. 添加用户, 并指定用户ID
  adduser -u 1001 user1
  # 3. 添加用户, 并指定用户ID, 并指定用户组
  adduser -u 1001 -g 1001 user1
  # 4. 添加用户, 并指定用户ID, 并指定用户组, 并指定用户主目录
  adduser -u 1001 -g 1001 -d /home/user1 user1
  # 5. 添加用户, 并指定用户ID, 并指定用户组, 并指定用户主目录, 并指定用户shell
  adduser -u 1001 -g 1001 -d /home/user1 -s /bin/bash user1
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -u   | 指定用户ID                                                   |
  | -g   | 指定用户组                                                   |
  | -d   | 指定用户主目录                                               |
  | -s   | 指定用户shell                                                |
  | ... | ...                                                          |

#### 3.4.2. 删除用户

* deluser命令: 用于删除用户

  ```shell
  # 语法: deluser [选项] 用户名
  # 1. 删除用户
  deluser user1
  # 2. 删除用户, 并指定用户主目录
  deluser -r user1
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -r   | 删除用户主目录                                               |
  | ... | ...                                                          |

#### 3.4.3. 修改用户

* usermod命令: 用于修改用户

  ```shell
  # 语法: usermod [选项] 用户名
  # 1. 修改用户
  usermod user1
  # 2. 修改用户, 并指定用户ID
  usermod -u 1001 user1
  # 3. 修改用户, 并指定用户ID, 并指定用户组
  usermod -u 1001 -g 1001 user1
  # 4. 修改用户, 并指定用户ID, 并指定用户组, 并指定用户主目录
  usermod -u 1001 -g 1001 -d /home/user1 user1
  # 5. 修改用户, 并指定用户ID, 并指定用户组, 并指定用户主目录, 并指定用户shell
  usermod -u 1001 -g 1001 -d /home/user1 -s /bin/bash user1
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -u   | 指定用户ID                                                   |
  | -g   | 指定用户组                                                   |
  | -d   | 指定用户主目录                                               |
  | -s   | 指定用户shell                                                |
  | ... | ...                                                          |

#### 3.4.4. 修改密码

* passwd命令: 用于修改密码

  ```shell
  # 语法: passwd [选项] 用户名
  # 1. 修改密码
  passwd user1
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -l   | 锁定用户                                                     |
  | -u   | 解锁用户                                                     |
  | ... | ...                                                          |

#### 3.4.5. 切换用户

* su命令: 用于切换用户

  ```shell
  # 语法: su [选项] 用户名
  # 1. 切换用户
  su user1
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -l   | 切换用户                                                     |
  | -u   | 切换用户                                                     |
  | ... | ...                                                          |

### 3.5. 管理文件权限

#### 3.5.1. 修改文件权限

* chmod命令: 用于修改文件权限

  ```shell
  # 语法: chmod [选项] 文件
  # 1. 修改文件权限
  chmod 777 a.txt
  # 2. 修改文件权限, 并指定权限
  chmod -R 777 a.txt
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -R   | 递归修改文件权限                                             |
  | ... | ...                                                          |

#### 3.5.2. 修改文件所有者

* chown命令: 用于修改文件所有者

  ```shell
  # 语法: chown [选项] 文件
  # 1. 修改文件所有者
  chown user1 a.txt
  # 2. 修改文件所有者, 并指定用户组
  chown user1:user1 a.txt
  # 3. 修改文件所有者, 并指定用户组, 并递归修改
  chown -R user1:user1 a.txt
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -R   | 递归修改文件所有者                                           |
  | ... | ...                                                          |

#### 3.5.3. 修改文件所属用户组

* chgrp命令: 用于修改文件所属用户组

  ```shell
  # 语法: chgrp [选项] 文件
  # 1. 修改文件所属用户组
  chgrp user1 a.txt
  # 2. 修改文件所属用户组, 并递归修改
  chgrp -R user1 a.txt
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -R   | 递归修改文件所属用户组                                       |
  | ... | ...                                                          |
### 3.6. 网络管理

#### 3.6.1. 检测网络

* ping命令: 用于检测网络

  ```shell
  # 语法: ping [选项] IP地址
  # 1. 检测网络
  ping 127.0.0.1
  ping www.baidu.com
  ping www.google.com
  ```

  运行结果:

  ![image-20230625145553227](img/image-20230625145553227.png)
  > ping使用网络层ICMP协议, 只可用于检测网络层, 无法检测应用层

### 3.7. Linux三剑客: grep, awk, sed
> grep之前已经介绍过了, 这里就不再赘述了
#### 3.7.1. awk命令: 用于处理数据文件

* awk命令: 用于处理数据文件

  ```shell
  # 语法: awk [选项] '条件1{动作1} 条件2{动作2} ...' 文件
  # 1. 处理数据文件
  awk '{print $1}' a.txt
  # 2. 处理数据文件, 并指定分隔符
  awk -F : '{print $1}' a.txt
  # 3. 处理数据文件, 并指定分隔符, 并指定条件
  awk -F : '$1 == "root" {print $1}' a.txt
  # 4. 处理数据文件, 并指定分隔符, 并指定条件, 并指定动作
  awk -F : '$1 == "root" {print $1}' a.txt
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -F   | 指定分隔符    
  | -f   | 指定脚本文件
  | -v   | 定义变量
  | -i   | 直接修改文件
  | ... | ...                                                          |

#### 3.7.2. sed命令: 用于处理数据文件

* sed命令: 用于处理数据文件

  ```shell
  # 语法: sed [选项] '条件1{动作1} 条件2{动作2} ...' 文件
  # 1. 处理数据文件
  sed 's/old/new/' a.txt
  # 2. 处理数据文件, 并指定分隔符
  sed -i 's/old/new/' a.txt
  # 3. 处理数据文件, 并指定分隔符, 并指定条件
  sed -i 's/old/new/g' a.txt
  # 4. 处理数据文件, 并指定分隔符, 并指定条件, 并指定动作
  sed -i 's/old/new/g' a.txt
  # ...
  ```

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -i   | 直接修改文件
  | -e   | 指定多个动作
  | -f   | 指定脚本文件
  | -r   | 使用扩展正则表达式
  | -n   | 不输出结果
  | ... | ...                                                          |
